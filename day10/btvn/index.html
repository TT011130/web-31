<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tìm hiểu về object</title>
</head>
<body>
    <h1>Object</h1>
    <h2>Khái niệm</h2>
    <p>Object đại diện cho một thực thể, gồm các thông tin chứa trong những thuộc tính (property) và 
        có những hành vi là những phương thức (method)</p>
    
    <h2>Tạo object</h2>
    <p>Có nhiều cách để tạo ra một object trong JS:</p>
    <ul>
        <li>Tạo single object bằng object literal (initializer)</li>
        <li>Tạo object bằng new và Object constructor</li>
        <li>Tạo object bằng một constructor tùy chỉnh</li>
        <li>Tạo từ class</li>
    </ul>
    <p>Từ ES5 có thể dùng method Object.create() để tạo object.</p>
    <h3>Object literal</h3>
    <p>Đây là cách đơn giản và rõ ràng nhất để tạo object. Nhược điểm là nó chỉ tạo ra một object duy nhất, 
        nên muốn tạo ra nhiều object cùng lúc cần dùng cách khác.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let shortObj = { name: "John", age: 20 };
        let longObj = {
            name: "John",
            age: 20
        }
    </p>
    <p>Chú ý hai cách viết trên, cách 1 ngắn gọn dùng cho object nhỏ, đơn giản. 
        Cách 2 tuy dài hơn nhưng rõ ràng và phù hợp cho các object phức tạp</p>
    
    <h3>New keyword & Object constructor</h3>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let john = new Object();
        john.name = "John";
        john.age = 20;
    </p>
    <p>Cách này sử dụng từ khóa new và Object constructor. Đầu tiên dòng 1 chỉ tạo ra object rỗng, 
        và rồi mới thêm các thuộc tính vào bằng cách gán value cho nó.</p>

    <h3>Define a constructor</h3>
    <p>Cách này khá giống cách ở trên, nhưng chúng ta sử dụng constructor tùy chỉnh thay vì Object. Constructor chỉ là một function bình thường, 
        gán giá trị cho this, và được gọi bằng new keyword.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        function createPerson(name, age) {
            this.name = name;
            this.age = age;
        }
        let john = new createPerson("John", 20);
    </p>
    <p>Cách này trước khi JS có class được dùng khá nhiều, vì nó có thể tạo ra được nhiều object tương tự nhau.</p>

    <h3>Instantiate from class</h3>
    <p>ES6 bổ sung thêm từ khóa class, nên có thể khởi tạo nhiều object từ một class đã định nghĩa. 
        Việc này tương tự trong các ngôn ngữ khác nên dễ làm quen hơn.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        class Person {
            constructor(name, age) {
                this.name = name;
                this.age = age;
            }
        }
        let john = new Person("John", 20);
    </p>

    <h3>Object.create()</h3>
    <p><code>Object.create()</code> là method rất hay để tạo object khi bạn muốn chọn prototype cho object tạo ra.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let Vehicle = {
            name: 'unknow',
            run: function () {
                console.log(this.name + ' is running');
            }
        }
        let car = Object.create(Vehicle);  // Tạo Car từ prototype của Vehicle
        car.name = 'Car';
        car.run();  // Car is running
    </p>

    <h2>Display object</h2>
    <p>Đôi khi chúng ta muốn xem tất cả giá trị của object, thì có thể dùng một số cách sau.</p>
    <ul>
        <li>Hiển thị một property</li>
        <li>Dùng vòng lặp for in để hiển thị tất cả property và value của chúng</li>
        <li>Dùng method Object.keys() hoặc Object.values() để lấy tất cả key hoặc value của object dạng array.</li>
        <li>Dùng method toString() hoặc JSON.stringify().</li>
        <li>Xuất ra bằng console.log().</li>
        <li>console.table() hiển thị toàn bộ object dưới dạng bảng trong console.</li>
    </ul>

    <h1>Property & Method</h1>
    <h2>Property</h2>
    <p>Thuộc tính (property) là nơi chứa dữ liệu cho object, mỗi thuộc tính là một cặp key: value. 
        Giữa tên thuộc tính key và value tách nhau bởi dấu hai chấm, và giữa các thuộc tính với 
        nhau cách nhau bởi dấu phẩy.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let obj = {
            name: "John",  // Thuộc tính name
            age: 20,  // Thuộc tính age
            callPolice: function () { console.log(113) }
        }
    </p>
    <p>Trong JS, các phương thức cũng được xem là thuộc tính, với value là một function, như trên.</p>
    <p>Tên thuộc tính đặc biệt có thể chứa khoảng trắng, khi đó cần dùng dấu nháy bao lại.</p>
    <p>Thuộc tính của object trong JS gồm 2 loại:</p>
    <ul>
        <li>Own property: do object định nghĩa</li>
        <li>Prototype property: có được từ prototype mà object thừa hưởng</li>
    </ul>

    <h3>Access property</h3>
    <p>Có hai cách để truy cập thuộc tính, nghĩa là đọc value hoặc thay đổi value của nó.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        console.log("My name is ", john.name);  // Đọc
        john["age"] = 21;  // Ghi
    </p>
    <p>Cách 1 sử dụng cú pháp object.property được dùng nhiều hơn.</p>
    <p>Cách 2 sử dụng cách truy cập như mảng object["property"], trong đó property là tên của thuộc tính.
        Cách 2 thường dùng khi tên property có dấu cách, hoặc truy cập các computed name property.</p>
    
    <h3>Add, delete property</h3>
    <p>Để thêm thuộc tính vào object, chỉ cần gán một value cho nó.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        john.isMale = true;  // Thêm thuộc tính isMale vào john
        john["isSingle"] = false;  // Cách này cũng được
    </p>
    <p>Để xóa thuộc tính, dùng toán tử delete. 
        Lưu ý delete chỉ có thể xóa được các own property, còn các property của prototype không xóa được.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);"> 
        delete john.isMale;
        delete john["isSingle"];
    </p>   
    <p>Chú ý, việc thêm và xóa thuộc tính có thể bị chặn vì object không cho phép. 
        Trong strict mode, delete bị cấm. Và nên hạn chế thêm hoặc xóa thuộc tính của object.</p>

    <h3>For in loop</h3>
    <p>Để duyệt qua các thuộc tính, sử dụng vòng lặp for in. 
        Vòng lặp này sẽ lặp qua tất cả thuộc tính, của cả object và prototype mà nó thừa hưởng.
    </p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        for (prop in john)
            console.log(prop, ": ", john[prop]);
    </p>
    <p>Biến prop mỗi lần lặp sẽ nhận lần lượt các property name, và sử dụng john[prop] để lấy giá trị property đang trỏ tới. 
        Chú ý phải dùng john[prop] mà không phải john.prop, vì prop ở đây không phải là thuộc tính cố định.</p>
    
    <h3>Property metadata</h3>
    <p>Thuộc tính trong JS có ba tính chất đặc biệt:</p>
    <ul>
        <li>Writable: cho phép thay đổi thuộc tính hay không</li>
        <li>Enumerable: cho phép thuộc tính được tìm thấy bằng vòng lặp for 
            in hoặc các method như Object.keys hoặc Object.values.</li>
        <li>Configurable: cho phép cấu hình thuộc tính, nghĩa là thay đổi được các thông số như writable, enumerable trên.
             Chỉ những thuộc tính có configurable mới có thể xóa bởi toán tử delete.</li>
    </ul>
    <p>Mọi thuộc tính trong JS đều có thể đọc được, do đó muốn bảo mật thì nên dùng closure thay thế.</p>

    <h3>Kiểm tra property có trong object hay không</h3>
    <p>Vì JS cho phép thêm, xóa property của object, nên đôi lúc chúng ta cần kiểm tra 
        xem object có chứa một property nào đó hay không. Có hai cách để làm việc này.</p>
    <ul>
        <li>Dùng toán tử in</li>
        <li>Dùng method hasOwnProperty()</li>
    </ul>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let john = { name: 'John' };
        'name' in john;  // true
        john.hasOwnProperty('name');  // true
    </p>
    <p>Sự khác biệt giữa chúng như sau:</p>
    <ul>
        <li>in kiểm tra property của chính object và của prototype, 
            ví dụ như 'toString' in john sẽ là true, vì toString là property của prototype.</li>
        <li>hasOwnProperty() method chỉ kiểm tra nếu property là của chính object đó, 
            ví dụ trên thì john.hasOwnProperty('toString') là false.</li>
    </ul>

    <h2>Method</h2>
    <p>Method là những function bên trong object, và các method cũng là property có value là function ẩn danh.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let john = {
            name: "John",
            age: 20,
            callPolice: function() { console.log("POLICE!!!"); },
            callMom() { console.log("Hello Mom"); }
        }
        john.callPolice();
        john.callMon();
    </p>
    <p>Hai method trên khai báo hai cách khác nhau. 
        Cách 1 là cách cũ trước đây, và cách 2 là cách viết method gọn hơn được giới thiệu từ ES6.</p>
    
    <h3>This keyword</h3>
    <p>Trong method, từ khóa this chỉ tới owner của method, là chính object chứa nó. 
        Do đó, chúng ta có thể gọi các method và property khác bên trong cùng object nhờ this.
    </p>
    <p>Trường hợp ngoại lệ khi gọi method bằng call() hoặc apply(). 
        Khi đó this sẽ là đối số đầu tiên (dạng object) khi gọi call(), apply().
    </p>

    <h3>Add method</h3>
    <p>Để thêm method vào, tương tự như thêm thuộc tính, chỉ cần gán value là một function ẩn danh cho nó.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        john.callDad = function() { console.log("Hi Dad"); }
    </p>

    <h1>Accessor, constructor & prototype</h1>

    <h2>Accessor</h2>
    <h3>Getter & setter</h3>
    <p>Từ ES5 đã giới thiệu getter và setter, nhờ đó thay vì truy cập thẳng vào thuộc tính thì phải thông qua
         một accessor (đối tượng truy cập). Sử dụng accessor tương tự như property, 
         khác biệt ở cách chúng hoạt động:
    </p>
    <ul>
        <li>Thuộc tính bình thường đọc ghi trực tiếp vào property.</li>
        <li>Accessor sử dụng getter để đọc và setter để ghi mỗi khi có yêu cầu tới thuộc tính. 
            Setter và getter là các hàm, bạn có thể viết code cho nó để chúng xử lý 
            dữ liệu trước khi đưa ra ngoài (getter) hoặc ghi vào property (setter).</li>
    </ul>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let john = {
            _name: "John",
            get name() {
                return this._name;
            }
            set name(value) {
                console.log("Tên tao ai cho mày thay đổi :D");
            }
        }
        console.log(john.name);  // Read name > get name()
        john.name = "Mike";  // Write name > set name()
    </p>
    <p>Thuộc tính _name là thuộc tính thực, trong đó name là accessor tạo bởi get name() và set name().
         Ở đây mình viết thuộc tính thực có dấu underscore _ phía trước.</p>
    <p>Khi đọc ghi trên accessor, thì tùy vào hành động (đọc hoặc ghi) thì getter (đọc) hoặc setter (ghi) sẽ được gọi tương ứng.</p>
    <p>Một thuộc tính có thể không có getter, setter, có một trong hai hoặc cả hai đều được.</p>

    <h3>Cấu trúc getter, setter</h3>
    <p>Getter có cấu trúc một method, không tham số và return một giá trị.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        get name() {
            ...
            return this._name;
        }
    </p>
    <p>Setter là method nhận vào một value, và không return giá trị nào.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        set name(value) {
            ...
        }
    </p>
    <p>Tên của method ở getter và setter là tên accessor phải trùng nhau, để trỏ tới cùng một accessor. Và tên accessor được sử dụng như tên property thông thường.</p>

    <h3>Tại sao dùng accessor</h3>
    <p>Một số lý do để sử dụng accessor như sau:</p>
    <ul>
        <li>Cú pháp đơn giản và giống nhau giữa property và method</li>
        <li>Đảm bảo luồng dữ liệu vào ra object hợp lệ và chuẩn</li>
        <li>Giúp thực hiện các thao tác khác trong nền khi truy cập thuộc tính</li>
    </ul>

    <h3>Accessor cho property có sẵn</h3>
    <p>Có thể định nghĩa thêm accessor cho một thuộc tính đã có mà không cần chỉnh sửa code object đó bằng method Object.defineProperty().</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let john = {
            _name: "John",
            age: 20
        }
        Object.defineProperty(john, "name", {
            get: function () { return this._name; },
            set: function (value) { this._name = value; }
        });
    </p>

    <h2>Constructor</h2>
    <p>Constructor chỉ là function dùng tạo object, và được gọi với từ khóa new. Constructor sử dụng từ khóa this đại diện object sẽ tạo ra, this sẽ được tự động return ra ngoài constructor thành một object mới.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        function Person(name, age) {
            this.name = name;
            this.age = age;
        }
        let john = new Person("John Doe", 20);
        let vu = new Person("Vu Tong", 19);
    </p>
    <p>Với constructor, có thể tạo ra nhiều object có cấu trúc giống nhau nhanh chóng, mặc dù giá trị trong đó có thể khác nhau. Constructor thường nhận vào các tham số, tương ứng với các thuộc tính sẽ có của object, và được gán cho this như trên.</p>
    <p>Với mỗi object tạo ra, nó sẽ có thuộc tính constructor giữ tham chiếu tới construcotrr tạo ra nó. Như ví dụ trên, thì john.constructor, vu.constructor sẽ cùng trỏ tới function Person().</p>
    
    <h3>This keyword</h3>
    <p>Tùy thuộc cách gọi function, gọi bình thường thì this là owner của function (object window hoặc object chứa method). Nếu gọi function có từ khóa new, thì function thành constructor, thì this mang ý nghĩa khác.</p>
    <p>This trong constructor là object tạm, khi constructor thực hiện xong thì object tạm sẽ được tạo ra và được gán tham chiếu cho một biến object.</p>

    <h3>Add property, method in constructor</h3>
    <p>Thêm như object bình thường, nhưng sử dụng this cho object chứ không phải bản thân constructor.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        function Person(name) {
            this.name = name;  // Ok
            Person.name = name;  // Sai
        }
    </p>
    
    <h3>Type constructors</h3>
    <p>Các kiểu dữ liệu có những constructor xây dựng sẵn, ví dụ object thì có Object(), string thì có String(), tương tự với Number(), Boolean(),... kể cả kiểu primitive.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let n = new Number(100);
        let s = new String("ABC");
    </p>

    <h2>Prototype</h2>
    <p>JS trước ES6 thì chưa có khái niệm class, nên việc thực hiện kế thừa (inheritance) giữa các object phải thông qua prototype (prototype based language)</p>
    <p>Có thể hiểu nếu hai object có cùng prototype, thì chúng sẽ có những thuộc tính và phương thức chung của prototype đó.</p>
    <p>prototype là một thuộc tính có trong mọi function, nếu function làm chức năng tạo ra object (là constructor), thì những object được tạo ra sẽ có chung những gì có trong prototype. Và những object đó sẽ lưu trữ một tham chiếu tới prototype gốc thông qua thuộc tính __proto__.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        // Tạo một function User
        function User(email, password) {
            this.email = email;
            this.password = password;
        }

        // Thêm thuộc tính vào User.prototype (prototype) cũng là 1 object
        User.prototype.name = 'Noname';

        // Bây giờ User.prototype trông như sau
        // {
        //     constructor: function () {...},  
        //     name: 'Noname'
        // }

        // Tạo object từ User
        let a = new User('a@a.com', '123');

        // Object a sẽ có tất cả mọi thứ từ User.prototype
        a.name;  // Noname

        // Xem thử thuộc tính a.__proto__
        a.__proto__;  // Tương tự User.prototype
    </p>
    <p>Về cơ bản thuộc tính prototype cũng là một object con, do đó nó có thể chứa method hoặc property. Và prototype luôn có một method tên là constructor là constructor sở hữu prototype.</p>
    <p>Đối với object tạo ra, nó sẽ có mọi thứ từ prototype của function tạo ra nó. Và những object đó có thuộc tính __proto__ để giữ tham chiếu tới prototype của function (dùng phép so sánh a.__proto__ === User.prototype cho kết quả true).</p>
    <p>Mọi thay đổi đối với function.prototype hoặc any_obj.__proto__ đều ảnh hưởng tới toàn bộ object khác có chung prototype đó.</p>

    <h1>Object constructor</h1>
    <p>Object trong JS là một constructor dùng để tạo ra các object. Bên cạnh đó, nó cũng chứa một số thuộc tính và phương thức xử lý cho mọi object, ví dụ như.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let obj = { ... };
        Object.keys(obj);
    </p>

    <h2>Object properties</h2>
    <p>Chỉ có hai property của Object là length và prototype.</p>
    <p>huộc tính length luôn trả về 1, và prototype cho phép bổ sung thêm các thành viên khác cho các object tạo ra từ Object.</p>

    <h2>Object methods</h2>
    <p>Tất cả các method của Object đều nhận vào một tham số là một object nào đó.</p>

    <h3>Object.create method</h3>
    <p>Tạo một object mới với prototype của một object khác được chỉ định</p>

    <h3>Object.keys & Object.values method</h3>
    <p>Method Object.keys() trả về một mảng các tên thuộc tính (còn gọi là key vì thuộc tính có tên: value, tương ứng với key: value).</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let john = { name: 'John', age: 20 };
        let arr = Object.keys(john);  // ['name', 'age']
    </p>
    <p>Nếu method không truyền object mà nhận vào string hoặc array, thì danh sách key lấy ra có dạng 1, 2, 3,... (vì string và array đánh index cho từng phần tử, nên key sẽ là index).</p>
    <p>Method Object.values() tương tự, nhưng nó trả về các value của thuộc tính thay vì key.</p>

    <h3>Object.getOwnPropertyNames method</h3>
    <p>Method Object.getOwnPropertyNames() tương tự như Object.keys(), dùng lấy ra một mảng các tên thuộc tính (key hoặc property name). Hoặc có một cách nữa là dùng vòng lặp for in để lặp qua mọi thuộc tính.</p>
    <p>Khác biệt ở chỗ Object.getOwnPropertyNames() lấy ra cả những thuộc tính enumerable là false, còn Object.keys() và for in không tìm thấy những thuộc tính không enumerable.</p>

    <h3>Object.seal & Object.freeze method</h3>
    <p>Method Object.seal() ngăn chặn việc xóa các thuộc tính của object. Method Object.freeze() cũng không cho phép xóa, và cũng không cho phép thay đổi value của bất kì thuộc tính nào trong object.</p>
    <p>Có hai method khác để kiểm tra là Object.isSealed() để kiểm tra object có được sealed không, và Obect.isFrozen() để kiểm tra tình trạng freeze của object.</p>

    <h3>Object.preventExtensions & Object.isExtensible</h3>
    <p>Method Object.preventExtensions() không cho phép thêm thuộc tính và method vào method.</p>
    <p>Và dùng method Object.isExtensible() để kiểm tra object có thể thêm thuộc tính và method vào không. Nếu đã dùng Object.preventExtensions() ở trên thì Object.isExtensible() là false.</p>

    <h3>Object,is method</h3>
    <p>Dùng method Object.is() để kiểm tra xem hai value có giống nhau hay không:</p>
    <ul>
        <li>Cả hai có cùng giá trị, undefined, null, hoặc true, hoặc false, hoặc string giống nhau.</li>
        <li>Đối với object (tính cả array), thì method trả về true khi cả hai có cùng địa chỉ bộ nhớ (hoặc tham chiếu cùng một object).</li>
        <li>Đối với số, thì nó phải giống nhau hoàn toàn, ví dụ +0 và -0 là khác nhau, Number.NaN và NaN là giống nhau, Number.POSITIVE_INFINITY và Infinity giống nhau.</li>
    </ul>
    <p>Nói chung thì Object.is() và hai phép so sánh == và === khá giống nhau, nhưng Object.is() giống với === hơn. Ví dụ.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        10 == '10';  // true
        10 === '10';  // false
        Object.is(10, '10');  // false
    </p>

    <h3>Object.assign method</h3>
    <p>Dùng method này để sao chép đối tượng nguồn (source) sang đối tượng đích (target) và trả về đối tượng đích. Nếu source không phải object, JS sẽ cố chuyển nó thành object bằng cách dùng wrapper cho nó.</p>
    <p>Method Object.assign() sao chép theo đúng nghĩa copy dữ liệu các thuộc tính và method vào object khác, còn phép gán = chỉ là gán tham chiếu thôi. Và chú ý các thuộc tính enumerable là false và accessor sẽ không được sao chép.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let source = { a: 10, b: 20 };
        let target = { b: 30, c: 40 };
        Object.assign(target, source);
            // target = { a: 10, b: 20, c: 40 };
    </p>

    <h3>Object.defineProperty method</h3>
    <p>Dùng method này để định nghĩa một thuộc tính mới, hoặc thay đổi các thông số của thuộc tính đã có.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        let john = { name: 'John', age: 20 };
        Object.defineProperty(john, 'isMale', {
            value: true
        });
    </p>

    <h3>Object.defineProperties method</h3>
    <p>Method Object.defineProperties() khá giống với Object.defineProperty(), khác biệt ở chỗ method số nhiều sẽ định nghĩa liên tiếp nhiều thuộc tính.</p>

    <h1>Classes</h1>
    <h2>Overview</h2>
    <p>Từ phiên bản ES6 (ECMAScript 2015) đã giới thiệu thêm class. Class về bản chất là một function constructor theo đúng nghĩa (typeof một class sẽ ra function), nhưng được viết với cú pháp gần với những ngôn ngữ khác hơn.</p>
    
    <h3>Definition</h3>
    <p>Cú pháp định nghĩa class như sau.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        class Person {
            constructor (name, age) {
                this.name = name;
                this.age = age;
                // Define properties here
            }
            // Define methods here 
        }
        let john = new Person('John', 20);
        john.
    </p>

    <h3>Inheritance</h3>
    <p>ES6 bổ sung thêm từ khóa extends để kế thừa class.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        class Student extends Person {
            constructor (name, age, school) {
                super(name, age);
                    // Luôn gọi đầu tiên, trước khi gán thuộc tính mới
                this.school = school;
            }
            ...
        }
        let a = new Student('Nguyen Van A', 17, 'Binh Thuan');
    </p>    
    <p>Để truy cập ngược lên lớp cha, sử dụng từ khóa super. Chú ý, khi kế thừa constructor lớp con thì luôn luôn gọi constructor lớp cha (nếu có) ở đầu tiên.</p>

    <h3>Hoisting</h3>
    <p>Class thì không được hoisting, mặc dù nó cũng là function.</p>

    <h3>Strict mode</h3>
    <p>Cú pháp viết class luôn phải tuân thủ strict mode, điều này là bắt buộc.</p>

    <h2>Methods</h2>

    <h3>Constructor</h3>
    <p>Constructor là một method đặc biệt, là nơi khởi tạo các thuộc tính cũng như kế thừa lớp cha. Constructor luôn được tự động gọi mỗi khi tạo object mới từ class.</p>
    <p>Một class chỉ có duy nhất một constructor, nếu không chỉ định constructor thì JS sẽ tự thêm constructor ẩn không làm gì cả.</p>
    <p>Constructor có các tham số như của function constructor, nhận những giá trị được truyền vào khi tạo object với new.</p>

    <h3>Method</h3>
    <p>Trong khi các thuộc tính định nghĩa bên trong constructor, thì các method sẽ được viết cùng cấp với constructor.</p>
    <p>Chú ý quan trọng, giữa các constructor và method, cũng như các method với nhau không có dấu phẩy, ví dụ.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        class Person {
            constructor () {
                ...
            },  // Dấu phẩy ở đây là sai
            method() {
                ...
            }
        }
    </p>

    <h3>Static method</h3>
    <p>Các static method sẽ được gọi từ class thay vì gọi từ object. Chỉ cần thêm từ khóa static vào đầu khai báo method.</p>
    <p>Vì static có từ ES6, nên nó phải dùng cách khai báo method mới của ES6, là static func() {} chứ không phải static func: function () {}.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        class Student extends Person {
            constructor (name, age, school) {
                super(name, age);
                this.school = school;
            }
            static introduce(student) {
                console.log(student.name, student.age, student.school);
            }
        }
        
        let a = new Student('Nguyen Van A', 17, 'Binh Thuan');
        let b = new Student('Le Thi B', 18, 'Quang Binh');
        
        Student.introduce(a);
        Student.introduce(b);
    </p>
    <p>Static method thường dùng để viết các tập method xử lý chính đối tượng đó, vì vậy tham số nhận vào là object tạo ra từ class đó.</p>

    <h2>Property</h2>
    <p>Định nghĩa property trong class thì nó phải ở trong constructor.</p>
    <p style="white-space: pre-wrap; width: 1000px; background-color: rgb(228, 225, 225);">
        class Person {
            constructor (name) {
                this._name = name;
            }
            get name() { return this._name; }
            set name(value) { this._name = value; }
        }
    </p>
</body>
</html>